#!/usr/bin/env python

"""
Parsers a YODA file generated by Rivet and generates
a simple text file with the efficiencies for every analysis/signal region
"""

import logging as logger
from math import sqrt


def getInfoFromBlock(yodaBlock,infoLabel):
    """
    Reads a YODA block (in string format)
    and returns the the value corresponding to infoLabel.
    infoLabel should appear in a header (line starting with #)
    or as a metadata field (e.g. Path)
    
    :param yodaBlock: string block (e.g. BEGIN YODA_COUNTER_V2...END YODA_COUNTER_V2)
    :param infoLabel: string (e.g. Path or numEnties)
    
    :return: infoValue (value for field, e.g. numEntries -> 100)
    
    """
    value = None
    
    lines = yodaBlock.split('\n')
    for i,l in enumerate(lines):
        if not infoLabel in l:
            continue
        if '#' in l:
            j = [s.strip() for s in l.replace('#','').split()].index(infoLabel)
            data = [v.strip() for v in lines[i+1].split()]
            value = data[j]
        else:
            value = l.split(':')[1]
        try:
            value = eval(value)
        except:
            pass
        
    return value


def getEffsFromFile(yodaFile):
    """
    Reads a yoda file and get the efficiencies for each analysis/signal region
    
    :param yodaFile: path to the yoda file
    
    :return: Nested dictionary with {analysisID : {SR1 : eff, SR2 : eff,...} ,...} 
    
    """
    
    f = open(yodaFile,'r')
    blocks = f.read().split('BEGIN YODA')
    f.close()
    effs = {}
    for block in blocks:
        if not block.strip():
            continue
        if 'EVTCOUNT' in block:
            ntotal = getInfoFromBlock(block, 'numEntries')
        elif 'XSEC' in block:
            xsecTotal = getInfoFromBlock(block, 'xval')
        else:            
            path = [x.strip() for x in getInfoFromBlock(block, 'Path').split('/') if x.strip()]
            if len(path) != 2:
                logger.error("Error getting analysis name and SR")
                return False
            analysisID,SR = path[0],path[1]
            nEntries = getInfoFromBlock(block, 'numEntries')
            if not analysisID in effs:
                effs[analysisID] = {SR : nEntries}
            else:
                effs[analysisID][SR] = nEntries
    for anaID in effs:
        for SR in effs[anaID]:
            effs[anaID][SR] = effs[anaID][SR]/ntotal
    effs['xsecTotal (pb)'] = xsecTotal
    effs['Ntotal'] = ntotal
    
    return effs 

def writeEffsToFile(effs,outfile):
    """
    Write effs to outfile in the format:
       #<header>
       #<analysisID-label>
          #<sr1-label>  <sr2-label> ...
          <eff_sr1>    <eff_sr2> ...
       #<analysisID-label>
          #<sr1-label>  <sr2-label> ...
          <eff_sr1>    <eff_sr2> ...
          
    """
    
    outF = open(outfile,'w')
        
    for key in effs:
        if not isinstance(effs[key],dict):
            outF.write('# %s: %s\n' %(key,effs[key]))
        else:
            outF.write('# %s \n' %key)
            SRs = sorted(list(effs[key].keys()))
            col_width = max(20,max(len(SR) for SR in SRs)) + 3  # padding
            outF.write("".join(SR.ljust(col_width) for SR in SRs)+'\n')
            outF.write("".join(("%.2e +- %.2e" %(effs[key][SR],sqrt(effs[key][SR])/effs['Ntotal'])).ljust(col_width)
                                for SR in SRs)+'\n')
    outF.close()
    
    
if __name__ == "__main__":

    import argparse    
    ap = argparse.ArgumentParser( description=
            "Get efficiencies from YODA file" )
    ap.add_argument('-f', '--inputName', 
            help='path to the (Rivet) YODA file', required = True)
    ap.add_argument('-o', '--outFile',
                    help='path to the output file', required = True)

    
    args = ap.parse_args()
    
    effs = getEffsFromFile(args.inputName)
   
    if effs:
        writeEffsToFile(effs,args.outFile)
    else:
        logger.error("Error getting effs from file %s" %args.inputName)

    
    