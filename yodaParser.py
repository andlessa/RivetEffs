#!/usr/bin/env python

"""
Parsers a YODA file generated by Rivet and generates
a simple text file with the efficiencies for every analysis/signal region
"""

import logging as logger,glob,os
from math import sqrt
import pyslha


def getInfoFromBlock(yodaBlock,infoLabel):
    """
    Reads a YODA block (in string format)
    and returns the the value corresponding to infoLabel.
    infoLabel should appear in a header (line starting with #)
    or as a metadata field (e.g. Path)
    
    :param yodaBlock: string block (e.g. BEGIN YODA_COUNTER_V2...END YODA_COUNTER_V2)
    :param infoLabel: string (e.g. Path or numEnties)
    
    :return: infoValue (value for field, e.g. numEntries -> 100)
    
    """
    value = None
    
    lines = yodaBlock.split('\n')
    for i,l in enumerate(lines):
        if not infoLabel in l:
            continue
        if '#' in l:
            j = [s.strip() for s in l.replace('#','').split()].index(infoLabel)
            data = [v.strip() for v in lines[i+1].split()]
            value = data[j]
        else:
            value = l.split(':')[1]
        try:
            value = eval(value)
        except:
            pass
        
    return value


def getEffsFromFile(yodaFile):
    """
    Reads a yoda file and get the efficiencies for each analysis/signal region
    
    :param yodaFile: path to the yoda file
    
    :return: Nested dictionary with {analysisID : {SR1 : eff, SR2 : eff,...} ,...} 
    
    """
    
    f = open(yodaFile,'r')
    blocks = f.read().split('BEGIN YODA')
    f.close()
    effs = {}
    for block in blocks:
        if not block.strip():
            continue
        if 'EVTCOUNT' in block:
            ntotal = getInfoFromBlock(block, 'numEntries')
        elif 'XSEC' in block:
            xsecTotal = getInfoFromBlock(block, 'xval')
        else:            
            path = [x.strip() for x in getInfoFromBlock(block, 'Path').split('/') if x.strip()]
            if len(path) != 2:
                logger.error("Error getting analysis name and SR")
                return False
            analysisID,SR = path[0],path[1]
            nEntries = getInfoFromBlock(block, 'numEntries')
            if not analysisID in effs:
                effs[analysisID] = {SR : nEntries}
            else:
                effs[analysisID][SR] = nEntries
    for anaID in effs:
        for SR in effs[anaID]:
            effs[anaID][SR] = effs[anaID][SR]/ntotal
    effs['xsecTotal (pb)'] = xsecTotal
    effs['Ntotal'] = ntotal
    
    return effs

def getEffsFromFolder(yodaFolder):
    """
    Reads yoda files from the yodaFolder and get the efficiencies for each file
    
    :param yodaFolder: path to the yoda folder
    
    :return: A nested dictionary with {filename: {analysisID : {SR1 : eff, SR2 : eff,...} ,...} 
    
    """
    
    effsList = {}
    for yodaFile in glob.glob(yodaFolder+'/*.yoda'):
        effs = getEffsFromFile(yodaFile)
        effsList[yodaFile] = effs
        
    return effsList


def writeEffsToFile(effsList,yodaFolder,slhaFolder,xpdg,ypdg):
    """
    Write effs to outfile in the format:
       #<header>
       #<analysisID-label>
          #<sr1-label>  <sr2-label> ...
          <eff_sr1>    <eff_sr2> ...
       #<analysisID-label>
          #<sr1-label>  <sr2-label> ...
          <eff_sr1>    <eff_sr2> ...
          
    """
    
    analysesIDs = []
    for f in effsList.keys():
        for key in effsList[f].keys():
            if isinstance(effsList[f][key],dict):
                analysesIDs.append(key)
    
    for analysisID in analysesIDs:
        outF = open(analysisID+'_eff.dat','w')
        outF.write('# %s\n' %analysisID)
        f = list(effsList.keys())[0]
        effs = effsList[f][analysisID]
        header = ['# mass_%i' %xpdg,'mass_%i' %ypdg]
        SRs = sorted(list(effs.keys()))
        header += SRs
        col_width = max(20,max(len(header) for h in header)) + 3  # padding            
        outF.write("".join(h.ljust(col_width) for h in header)+'\n')                 
        for f in effsList:
            effs = effsList[f][analysisID]
            slhaFile = os.path.basename(f.replace('.yoda','.slha'))
            slhaFile = os.path.join(slhaFolder,slhaFile)            
            slhaData = pyslha.readSLHAFile(slhaFile)
            xval = slhaData.blocks['MASS'][xpdg]
            yval = slhaData.blocks['MASS'][ypdg]
            xvals = [xval,yval]
            vals = [effs[SR] for SR in SRs]
#             errvals = [sqrt(effs[SR])/effsList[f]['Ntotal'] for SR in SRs]
            outF.write("".join(("%.6e " %x).ljust(col_width) for x in xvals))                    
#             outF.write("".join(("%.2e +- %.2e" %(v,errvals[i])).ljust(col_width)
#                                 for i,v in enumerate(vals))+'\n')
            outF.write("".join(("%.2e" %(v)).ljust(col_width)
                                for v in vals)+'\n')
            
        outF.close()
    
    
if __name__ == "__main__":

    import argparse    
    ap = argparse.ArgumentParser( description=
            "Get efficiencies from YODA folder" )
    ap.add_argument('-f', '--yodaFolder', 
            help='path to the folder containing (Rivet) YODA files', required = True)
    ap.add_argument('-s', '--slhaFolder', 
            help='path to the folder containing SLHA files', required = True)
    ap.add_argument('-x', '--xpdg', 
            help='PDG for the particle in the x-axies', default = 1000021)
    ap.add_argument('-y', '--ypdg',
            help='PDG for the particle in the y-axies', default = 1000022)

    
    args = ap.parse_args()
    
    effs = getEffsFromFolder(args.yodaFolder)
    if effs:
        writeEffsToFile(effs,args.yodaFolder,args.slhaFolder,args.xpdg,args.ypdg)
    else:
        logger.error('No analyses found in %s' %args.yodaFolder)

    
    
